use std::collections::HashSet;

#[derive(Clone)]
struct Node {
    val: char,
    record: Option<usize>
}
struct Board {
    width: usize,
    height: usize,
    board: Vec<Vec<Node>>,
    
    start_i: usize,
    start_g: usize,
    end_i:   usize,
    end_g:   usize,
    lowest_score: Option<usize>,
    lowest_visited: Option<Vec<(usize, usize)>>
}
impl Board {
    fn new (
        board: Vec<Vec<Node>>,
        start_i: usize,
        start_g: usize,
        end_i: usize,
        end_g: usize
    ) -> Self {
        Self {
            width: board[0].len(),
            height: board.len(),
            board,

            start_i,
            start_g,
            end_i,
            end_g,
            lowest_score: None,
            lowest_visited: None
        }
    }
    fn render ( &self ) {
        println!("Current board state:");
        for row in self.board.iter() {
            for node in row.iter() {
                if node.val == '#' {
                    print!("####");
                    continue;
                }
                print!("    ");
            }
            println!();
            for node in row.iter() {
                if node.val == '#' {
                    print!("####");
                    continue;
                }
                print!(
                    " {:02} ", 
                    node.record
                        .map(|rc| rc.to_string())
                        .unwrap_or(String::from(":3"))
                );
            }
            println!();
            for node in row.iter() {
                if node.val == '#' {
                    print!("####");
                    continue;
                }
                print!("    ");
            }
            println!();
        }
    }
    fn reset (
        &mut self
    ) {
        for i in 0..self.board.len() {
            for g in 0..self.board[i].len() {
                self.board[i][g].record = None;
            }
        }
        self.lowest_score = None;
    }
    fn shortest_normal_distance (
        &mut self
    ) -> Option<usize> {
        self.traverse(
            self.start_i,
            self.start_g,
            0,
            vec!()
        );
        
        self.lowest_score
    }
    fn traverse ( 
        &mut self,
        i: usize,
        g: usize,
        score: usize,
        mut visited: Vec<(usize, usize)>
    ) {
        //println!("Traversed to ({}, {}) with a score of {}", g, i, score);
        visited.push((i, g));
        if (i, g) == (self.end_i, self.end_g) {
            //println!("Hit the final node with a score of {score}!");

            if let Some(lowest_score) = self.lowest_score {
                if score < lowest_score {
                    self.lowest_score = Some(score);
                    self.lowest_visited = Some(visited);
                }
            } else {
                self.lowest_score = Some(score);
                self.lowest_visited = Some(visited);
            }
            return;
        }

        if i > 0 && self.board[i - 1][g].val == '.' &&
            ( self.board[i - 1][g].record.is_none() || 
              (score + 1) < self.board[i - 1][g].record.unwrap() )
        {
            self.board[i - 1][g].record = Some(score + 1);
            self.traverse (
                i - 1,
                g,
                score + 1,
                visited.clone()
            );
        }
        if i < self.height - 1 && self.board[i + 1][g].val == '.' &&
            ( self.board[i + 1][g].record.is_none() || 
              (score + 1) < self.board[i + 1][g].record.unwrap() )
        {
            self.board[i + 1][g].record = Some(score + 1);
            self.traverse (
                i + 1,
                g,
                score + 1,
                visited.clone()
            );
        }
        if g > 0 && self.board[i][g - 1].val == '.' &&
            ( self.board[i][g - 1].record.is_none() || 
              (score + 1) < self.board[i][g - 1].record.unwrap() )
        {
            self.board[i][g - 1].record = Some(score + 1);
            self.traverse (
                i,
                g - 1,
                score + 1,
                visited.clone()
            );
        }
        if g < self.width - 1 && self.board[i][g + 1].val == '.' &&
            ( self.board[i][g + 1].record.is_none() ||
            (score + 1) < self.board[i][g + 1].record.unwrap() )
        {
            self.board[i][g + 1].record = Some(score + 1);
            self.traverse (
                i,
                g + 1,
                score + 1,
                visited
            );
        }

    }
}
fn taxicab_distance (
    i_1: usize,
    g_1: usize,
    i_2: usize,
    g_2: usize
) -> usize {
    i_1.abs_diff(i_2) + g_1.abs_diff(g_2)
}
fn main() {
    let mut start_i: Option<usize> = None;
    let mut start_g: Option<usize> = None;
    let mut end_i:   Option<usize> = None;
    let mut end_g:   Option<usize> = None;
    let board = std::fs::read_to_string("input.txt")
        .unwrap()
        .lines()
        .enumerate()
        .map(|(i, ln)| {
            ln.chars()
                .enumerate()
                .map(|(g, ch)| {
                    match ch {
                        'S' => {
                            start_i = Some(i);
                            start_g = Some(g);
                            Node { val: '.', record: None }
                        },
                        'E' => {
                            end_i = Some(i);
                            end_g = Some(g);
                            Node { val: '.', record: None }
                        },
                        '.' => Node { val: '.', record: None },
                        '#' => Node { val: '#', record: None },
                        _ => panic!("Invalid input!")
                    }
                })
                .collect::<Vec<Node>>()
        })
        .collect::<Vec<Vec<Node>>>();

    let start_i = start_i.unwrap();
    let start_g = start_g.unwrap();
    let end_i   = end_i.unwrap();
    let end_g   = end_g.unwrap();
    let mut base_board = Board::new(
        board.clone(),
        start_i,
        start_g,
        end_i,
        end_g
    );
    println!(":3");

    let lowest_score = base_board.shortest_normal_distance().unwrap();
    base_board.render();
    println!(":3");

    let mut over_100 = 0usize;
    for (i, row) in base_board.board.iter().enumerate() {
        for (g, node) in row.iter().enumerate() {
            if node.val == '#' { continue; }
            for radius in 1..2 {
                for dist_row in 0..radius {
                    let dist_col = radius - dist_row;
                    let to_check = HashSet::from([
                            (i as i32 + dist_row as i32, g as i32), 
                            (i as i32 + 1 as i32, g as i32 + 1 as i32), 
                            (i as i32, g as i32 + dist_col as i32),
                            (i as i32 - 1 as i32, g as i32 + 1 as i32)
                    ]);
                    for (ni, ng) in to_check.into_iter() {
                        if ni < 0 || ng < 0 ||
                            ni as usize >= base_board.board.len() || 
                            ng as usize >= base_board.board[0].len()
                        {
                            continue;
                        }
                        if base_board.board[ni as usize][ng as usize].val == '#' {
                            continue;
                        }
                        let first = base_board.board[i][g].record;
                        let second = base_board.board[ni as usize][ng as usize].record;
                        if first.is_some() && second.is_some() &&
                        (first.unwrap() as i32 - second.unwrap() as i32).abs() >= 100 + 2 {
                            over_100 += 1;
                        }
                    }
                }
            }
        }
    }
    println!("Cheats that save over 100: {over_100}");
}
